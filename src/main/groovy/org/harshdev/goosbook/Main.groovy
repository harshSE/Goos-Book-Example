/*
 * This Groovy source file was generated by the Gradle 'init' task.
 */
package org.harshdev.goosbook

import org.harshdev.goosbook.auctionsniper.ui.MainWindow
import org.harshdev.goosbook.auctionsniper.ui.SniperTableModel
import org.harshdev.goosbook.auctionsniper.ui.UserEventListener
import org.jivesoftware.smack.chat2.Chat
import org.jivesoftware.smack.chat2.ChatManager
import org.jivesoftware.smack.chat2.IncomingChatMessageListener
import org.jivesoftware.smack.packet.Message
import org.jivesoftware.smack.tcp.XMPPTCPConnection
import org.jivesoftware.smack.tcp.XMPPTCPConnectionConfiguration
import org.jxmpp.jid.EntityBareJid
import org.jxmpp.jid.impl.JidCreate

import javax.swing.*

import static org.jivesoftware.smack.chat2.ChatManager.getInstanceFor

class Main {

    private static final int ARGS_HOSTNAME = 0
    private static final int ARGS_USERNAME = 1
    private static final int ARGS_PASSWORD = 2
    private static final int ARGS_ITEM_ID = 3
    private static final String AUCTION_RESOURCE = "auction"
    static final String MAIN_WINDOW_NAME = ""

    private static  XMPPTCPConnection connection
    private static Main main

    private MainWindow ui
    private ChatManager chatManager


    Main() throws Exception {
        startUserInterface()
    }

    static void main(String[] args) {
        main = new Main();

        connection(args)

        main.joinAuction(connection, args[ARGS_ITEM_ID])

    }

    private static void connection(String[] args) {
        XMPPTCPConnectionConfiguration configuration = XMPPTCPConnectionConfiguration.builder()
                .setUsernameAndPassword(args[ARGS_USERNAME], args[ARGS_PASSWORD])
                .setResource(AUCTION_RESOURCE)
                .setXmppDomain("harshdev.com")
                .setHost(args[ARGS_HOSTNAME])
                .build();
        connection = new XMPPTCPConnection(configuration)
    }

    private void joinAuction(XMPPTCPConnection connection, String itemId) {
        login(connection)

        chatManager = getInstanceFor(connection)

    }

    private void joinAuction(String item) {
        String jid = createAuctionIdForXmpp(item, connection)

        Chat chat = this.chatManager.chatWith(JidCreate.entityBareFrom(jid))

        Auction auction = new XMPPAuction(chat)

        addListener(item, this.chatManager, auction, chat)

        auction.join()
    }

    private login(XMPPTCPConnection connection) {
        connection.connect().login()
    }

    private GString createAuctionIdForXmpp(String itemId, XMPPTCPConnection connection) {
        "auction-${itemId}@${connection.getXMPPServiceDomain()}/${AUCTION_RESOURCE}"
    }

    private boolean addListener(String item, ChatManager chatManager, Auction auction, Chat chat) {
        SwingThreadSniperListener sniperListener = new SwingThreadSniperListener()
        AuctionSniper sniper = new AuctionSniper(item, sniperListener, auction)
        String user = connection.getUser().toString()
        AuctionMessageTranslator translator = new AuctionMessageTranslator(user, sniper)

        sniperListener.sniperStateChanged(SniperSnapShot.joining(item))

        //FIXME adding lister for each auction will cause memory leak as message listener never release even though chat ended i.e auction closed.
        IncomingChatMessageListener listener = new XMPPMessageIncomingMessageListener(translator, chat)
        chatManager.addIncomingListener(listener)
    }

    static void stop() {
        if (Objects.nonNull(connection)) {
            connection.disconnect()
        }

        main.ui.dispose()
    }

    private void startUserInterface() throws Exception {
        SwingUtilities.invokeAndWait(() -> ui = new MainWindow(new SniperTableModel(), new UserEventListener() {
            @Override
            void joinAuction(String item) {
                new Thread(() -> Main.this.joinAuction(item)).start()
            }
        }))
    }


    static class XMPPMessageIncomingMessageListener implements IncomingChatMessageListener{

        private AuctionMessageTranslator translator
        private Chat chat

        XMPPMessageIncomingMessageListener(AuctionMessageTranslator translator, Chat chat) {
            this.translator = translator
            this.chat = chat
        }

        @Override
        void newIncomingMessage(EntityBareJid from, Message message, Chat chat) {
            if(this.chat != chat) {
                return
            }

            this.translator.processMessage(message)
        }
    }

    static class XMPPAuction implements Auction {

        private static final String JOIN_COMMAND = "SOLVersion: 1.1; Command: JOIN;"
        private static final def BID_FOR_PRICE_OF = { int price -> "Command: BID; Price: ${price};" }
        private Chat chat;


        XMPPAuction(Chat chat) {
            this.chat = chat;
        }

        @Override
        void bid(int price) {
            chat.send(BID_FOR_PRICE_OF(price))
        }

        @Override
        void join() {
            chat.send(JOIN_COMMAND)
        }
    }

    class SwingThreadSniperListener implements SniperListener {
        @Override
        void sniperStateChanged(SniperSnapShot snapShot) {
            SwingUtilities.invokeAndWait(() -> ui.sniperStatusChange(snapShot))
        }
    }
}
